<!DOCTYPE html>
<html>
<head>
<title>Spring Core 3.2 - Certification Study Notes</title>

<link href="gcp/prettify.css" type="text/css" rel="stylesheet" />
<script type="text/javascript" src="gcp/run_prettify.js"></script>

<link href="favicon.ico"  rel="icon" type="image/x-icon" />

<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="keywords" content="spring certification, spring, certification, springsource, core, study guide, notes, question, exam">
<meta name="description" content="Core Spring Professional Certification Study Notes / Guides, Resources, Mock Exams">
<meta name="author" content="Arnošt Havelka"> 
</head>

<body>
	<h1>Spring Core 3.2 - Study Notes © 2013 Arnošt Havelka</h1>

	<h2>Disclaimer</h2>
    <p>This artical is heavily based on artical <strong><a href="http://springcert.sourceforge.net/">Core Spring Professional Certification Study Guides, Resources, Mock Exams</a> by Gavin Lasnitzki</strong> 
		(and of course <strong><a href="http://www.selikoff.net/2010/08/20/jeannes-core-spring-3-certification-experiences/">jeanne’s core spring 3 certification experiences</a> by Jeanne Boyarsky</strong>). 
		My notes are "serious" re-work ot their notes. It contains changes to be closer to exam scope, my ideas and updates to spring framework 3.2.x.</p>
	
	<h2>SpringSource Certification</h2>
	<p>Summary of <a href="http://mylearn.vmware.com/mgrReg/plan.cfm?plan=31110&ui=www_cert">certification</a> exam defined in <a href="http://mylearn.vmware.com/courseware/152239/core-spring-3.0-certification-study-guide.pdf">study guide</a> is:
		<ul>
			<li>Computer-based exam (any Paerson VUE Test Center)</li>
			<li>90 minutes</li>
			<li>Passing score 76% (38 questions answered successfully)</li>
		</ul>
	</p>

	<h2>Spring Reference Docs 3.2.x</h2>
	<ul>
		<li> Reference Manual ( <a target="_core3" href="http://static.springsource.org/spring/docs/3.2.x/spring-framework-reference/html">HTML</a> / <a target="_core3" href="http://static.springsource.org/spring/docs/3.1.x/spring-framework-reference/pdf/spring-framework-reference.pdf">PDF</a> ) </li>
		<li> <a target="_core3" href="http://static.springsource.org/spring/docs/3.2.x/javadoc-api/">API</a> (Javadoc) </li>
		<li> <a target="_core3" href="http://static.springsource.org/spring/docs/3.2.x/changelog.txt">Change Log</a></li>
	</ul>

	<hr/>

    <h2>1. Container</h2>
    <h3>1.1 General</h3>
    <h4>1.1.1 The potential advantages of using Spring's dependency injection?</h4>
	<ul>
		<li>Instances/objects get what they need (simplifies code, improves reusability, frees from resolving dependencies)</li>
		<li>Promotes programming to interfaces (leads to loosely coupled code)</li>
		<li>Improves testability (dependency can be easily mocked or stubbed)</li>
		<li>Centralized object's lifecycle control (autowire, dependency checking)</li>
	</ul>
    <h4>1.1.2 Dependency injection in XML, using constructor or setter injection</h4>
	<font color='blue' size="4">Constructor</font>
    <p><strong>&lt;constructor-arg/&gt;</strong></p>
    <p>Only works if there is no ambiguity in args. Use the following attributes to reduce ambiguity:</p>
    <ul>
		<li>
			&quot;type&quot; matching by specifying argument type
<pre class="prettyprint"><code class="language-xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
	&lt;constructor-arg type="int"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/constructor-arg&gt;
	&lt;constructor-arg type="java.lang.String">&lt;value>abc&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
		</li>
		<li>
			&quot;index&quot; by specifying position (zero  based)
<pre class="prettyprint"><code class="language-xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
	&lt;constructor-arg index="0"&gt;&lt;value&gt;7500000&lt;/value&gt;&lt;/constructor-arg&gt;
	&lt;constructor-arg index="1">&lt;value>abc&lt;/value&gt;&lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
		</li>
	</ul>
	<p><strong>C namespace</strong> -  similar to P namespace</p>
<pre class="prettyprint"><code class="language-xml">&lt;beans ...  xmlns:c="http://www.springframework.org/schema/c"&gt;
-- by name
&lt;bean id="foo" class="x.y.Foo" c:bar-ref="bar" c:baz-ref="baz" c:email="foo@bar.com"&gt;
-- by index
&lt;bean id="foo" class="x.y.Foo" c:_0-ref="bar" c:_1-ref="baz"&gt;
</code></pre>

	<font color='blue' size="4">Setter</font>
	<p><strong>&lt;property/&gt;</strong></p>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
	&lt;property name="value" value="my value"/&gt; -- literal value
	&lt;property name="service" ref="myService"/&gt; -- refence to other bean
&lt;/bean&gt;
</code></pre>
	<p><strong>P namespace</strong></p>
<pre class="prettyprint"><code class="language-xml">&lt;beans ...  xmlns:p="http://www.springframework.org/schema/p"&gt;
&lt;bean id="foo" class="x.y.Foo" p:value="my value" p:service-ref="myService"/&gt;
</code></pre>

    <h4>1.1.3 Scopes</h4>
	<ul>
		<li><strong>Singleton</strong> (default) - a single instance is used (in context)</li>
		<li><strong>Prototype</strong> - each usage has new instance</li>
		<li><strong>Session</strong> - every user's session has its own instance (web environment)</li>
		<li><strong>Request</strong> - every user's request has its own instance (web environment)</li>
		<li><strong>Custom</strong> - define scope by your needs (e.g. 'flow' in Spring WebFlow)</li>
    </ul>

	<h3>1.2 Lifecycle</h3>
	<svg style="width:400px; height:350px;">
		<text x="80" y="20">Definition of application context</text>
		<line x1="180" y1="35" x2="180" y2="80" stroke="#000000" stroke-width="2"/>
		<line x1="170" y1="70" x2="180" y2="80" stroke="#000000" stroke-width="2"/>
		<line x1="190" y1="70" x2="180" y2="80" stroke="#000000" stroke-width="2"/>
		<text x="190" y="65" fill="blue">1</text>
		
		<text x="0" y="130">BFPP</text>
		<line x1="20" y1="110" x2="100" y2="110" stroke="#000000" stroke-width="2"/>
		<line x1="90" y1="100" x2="100" y2="110" stroke="#000000" stroke-width="2"/>
		<line x1="90" y1="120" x2="100" y2="110" stroke="#000000" stroke-width="2"/>
		<text x="40" y="105" fill="blue">2 + 3</text>
					
		<rect x="100" y="80" width="150" height="60" stroke="#000000"	stroke-width="4" fill="#AAAAFF" />
		<text x="120" y="120">Bean Definition</text>
		
		<line x1="180" y1="140" x2="180" y2="180" stroke="#000000" stroke-width="2"/>
		<line x1="170" y1="170" x2="180" y2="180" stroke="#000000" stroke-width="2"/>
		<line x1="190" y1="170" x2="180" y2="180" stroke="#000000" stroke-width="2"/>
		<text x="190" y="165" fill="blue">4 + 5</text>
		
		<text x="0" y="230">BPP</text>
		<line x1="20" y1="210" x2="100" y2="210" stroke="#000000" stroke-width="2"/>
		<line x1="90" y1="200" x2="100" y2="210" stroke="#000000" stroke-width="2"/>
		<line x1="90" y1="220" x2="100" y2="210" stroke="#000000" stroke-width="2"/>
		<text x="40" y="205" fill="blue">7 + 10</text>

		<rect x="100" y="180" width="150" height="60" stroke="#000000"	stroke-width="4" fill="#AAAAFF" />
		<text x="140" y="220">Instance</text>
		
		<line x1="180" y1="240" x2="180" y2="290" stroke="#000000" stroke-width="2"/>
		<line x1="170" y1="280" x2="180" y2="290" stroke="#000000" stroke-width="2"/>
		<line x1="190" y1="280" x2="180" y2="290" stroke="#000000" stroke-width="2"/>
		<text x="190" y="275" fill="blue">5</text>
		
		<text x="160" y="310">Ready</text>
	</svg>
	<ol><strong>Init:</strong>
		<li>Load all  bean definitions to create an ordered graph (the  container tries to set properties and resolve dependencies as late as possible)</li>
		<li>Instantiate bean definition</li>
		<li>Instantiate each bean</li>
		<li>Set properties</li>
		<li>BeanPostProcessors (#postProcessBeforeInitialization)</li>
		<li>@PostConstruct</li>
		<li>InitializingBean (#afterPropertiesSet)</li>
		<li>Call init-method</li>
		<li>BeanPostProcessors (#postProcessAfterInitialization)</li>
	</ol>
	<ol><strong>Destroy:</strong>
		<li>@PreDestroy</li>
		<li>DisposableBean (#destroy)</li>
		<li>Call destroy-method</li>
	</ol>
	<font color='blue' size="4">BeanFactoryPostProcessors vs. BeanPostProcessors</font>
	<ul><strong>BeanFactoryPostProcessors</strong>
		<li>Each processor is called once per xml (i.e per  application context)</li>
		<li>Before beans are instantiated</li>
		<li>Can change bean configuration / definitions</li>
		<li>If BeanFactoryPostProcessors are marked as being  lazily-initialized they will NOT be instantiated and will NOT apply their logic.</li>
	</ul>
	<ul><strong>BeanPostProcessors</strong>
		<li>Each processor is called once per bean</li>
		<li>Can run before / after a bean is initialised </li>
	</ul>
    <h4>1.2.1 How to declare an initialization method in a Spring bean?</h4>
	<ul>
		<li>XML: &lt;bean ... <strong>init-method</strong>="init"&gt;</li>
		<li>JSR-250: annotation <strong>@PostConstruct</strong> on method</li>
		<li>Implement <strong>BeanPostProcessors#xyzProcessBeforeInitialization</strong></li>
		<li>Implement <strong>InitializingBean#afterPropertiesSet</strong></li>
	</ul>
    <h4>1.2.2 How to declare a destroy method in a Spring bean?</h4>
	<ul>
		<li>XML: &lt;bean ... <strong>destroy-method</strong>="finish"&gt;</li>
		<li>JSR-250: annotation <strong>@PreDestroy</strong> on method</li>
		<li>Implement <strong>DisposableBean#destroy</strong></li>
	</ul>
    <h4>1.2.3 Default bean instantiation policy: when are beans instantiated?</h4>
	<ul>
		<li>For Singleton - when app context is created / parsed</li>
		<li>For Prototype - anytime the bean is required</li>
		<li>Lazy loading instantiation policy (when first referenced) - attributes &quot;lazy-init&quot; on the &lt;bean/&gt; element or &quot;default-lazy-init&quot; on the &lt;beans/&gt; element</li>
	</ul>

	<p><font color='blue' size="4">Mem:</font></p>
	<ul>
		<li>Order (by component): XML context, BFPP, new, set, BPP#before,  init[@PostConstruct, Init#afterPropertiesSet, init-method], BPP#after, dispose[@PreDestroy,  Disp#destroy, destroy-method]</li>
		<li>Sequence (by type): init / destroy order is: (@) annotation, (#)  interface method, (-) xml attribute</strong></li>
	</ul>
	<h4><font color='brown'>1.2.x What is a BeanFactory?</font></h4>
	<p>Underlying basis for Spring's IoC functionality</p>	

	<h3>1.3 Annotations</h3>
	<h4>1.3.1 Enabling component-scanning</h4>
	<p></p>
	<ul>
		<li>Use <strong>&lt;context:component-scan /&gt;</strong> for @Component (general), @Controller (web),  @Repository (dao) and @Service (service)</li>
		<li>Options:include-filter and context:exclude-filter elements</li>
		<li>Components (including JAR dependencies) are scanned at startup</li>
	</ul>
	<p>Example:</p>
<pre class="prettyprint"><code class="language-xml">&lt;context:component-scan  base-package="org.example"&gt;
    &lt;context:include-filter type="regex"  expression=".*Stub.*Repository"/&gt;
    &lt;context:exclude-filter type="annotation"  expression="org.springframework.stereotype.Repository"/&gt;
&lt;/context:component-scan>
</code></pre>
	<h4>1.3.2 Behavior of the annotation @Autowired with regards to field  injection, constructor injection and method injection</h4>
	<ul>Modes:
		<li><strong>no</strong>: (default) No auto-wiring will be performed.  You must wire the dependencies explicitly.</li>
		<li>byName: For each bean property, wire a bean with  the same name as the property.</li>
		<li>byType: For each bean property, wire a bean  whose type is compatible with that of the property.</li>
		<li>constructor: If a default constructor with no  argument is found, the dependencies will be auto-wired by type. Otherwise, they  will be auto-wired by constructor.</li>
	</ul>
	<p>If &gt; 1 match, throws exception (unless injecting into  Collection). <br>
		If no matches, autowiring fails unless using @Required or  &quot;required&quot; attribute</p>
	<p>May be applied to: </p>
	<ul>
		<li>setter methods</li>
		<li>methods with arbitrary names and/or multiple  arguments</li>
		<li>constructors</li>
		<li>fields (even private ones)</li>
		<li>arrays (whereby all beans of a particular type  from the ApplicationContext are injected)</li>
		<li>typed collections</li>
		<li>typed maps (as long as the key is a  java.lang.String )</li>
	</ul>
	<h4>1.3.3 How does the @Qualifier annotation complement the use of @Autowired?</h4>
	<ul>
		<li><strong>@Qualifier(name)</strong> - to define specific bean name if desired or needed (e.g. to choose one of many beans of same type)</li>
		<li>the bean name is:
			<ul>
				<li>considered as a default qualifier value (when no qualifier is defined)</li>
				<li>auto-generated when not specified (but not accessible)</li>
				<li>avoid using name when possible</li>
			</ul>
		</li>
	</ul>
	<h4>1.3.4 What is the role of the @PostConstruct and @PreDestroy annotations?</h4>
	<p>Similar to init-method and destroy-method </p>
	<h4>1.3.5 Enabling the scanning of annotations such as @Required and  @PreDestroy?</h4>
	<p>Use <strong>&lt;context:annotation-config /&gt;</strong> for (Spring's @Required and @Autowired, JSR  250's @PostConstruct, @PreDestroy and @Resource, 
		PA's @PersistenceContext and  @PersistenceUnit) and process all DI annotations.</p>
	<ul>
		<li>&lt;context:component-scan /&gt; can also do what &lt;context:annotation-config /&gt; does but &lt;context:component-scan /&gt; also scans packages to find and register beans within the application context.</li>
		<li>@Required goes on setters, not fields</li>
		<li>@PostConstruct, @PreDestroy goes on methods</li>
	</ul>
	<h4><font color='brown'>1.3.6 Other</font></h4>
	<font color='blue'>Other annotations</font>
	<ul>
		<li>@Scheduled(fixedDelay=5000)</li>
		<li>@Async</li>
	</ul>
	<font color='blue'>SpEL</font>
	<ul>
		<li>Code: (new  SpelExpressionParser()).parseExpression(&quot;numberGuess.randomNumber&quot;).getValue(target)</li>
		<li>Xml: value=&quot;#{numberGuess.randomNumber}&quot;/&gt;</li>
		<li>Annotation:  @Value(&quot;#{numberGuess.randomNumber}&quot;)</li>
	</ul>

	<h3>1.4 Miscellaneous</h3>
	<h4>1.4.1 How to inject scalar/literal values into Spring beans?</h4>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="exampleBean" class="examples.ExampleBean"&gt;
	&lt;property ...&gt;<strong>&lt;value&gt;b@b.com&lt;/value&gt;</strong>&lt;/property&gt; -- element
	&lt;property ... <strong>value=&quot;b@b.com&quot;</strong> /&gt; -- attribute
	&lt;bean ...  <strong>p:email=&quot;b@b.com&quot;</strong> /&gt; - P namespace
&lt;/bean&gt;
</code></pre>
	<ul>
		<li>Empty: &lt;property  name=&quot;email&quot;&gt;&lt;value/&gt;&lt;/property&gt;</li>
		<li>Null: &lt;property name=&quot;a&quot;&gt;&lt;null  /&gt;&lt;/property&gt;</li>
		<li>Compound property names: person.address.streetNo</li>
		<li>Annotation @Value (see chapter 1.3.x)</li>
	</ul>
	<h4>1.4.2 How to refer to a collection in a Spring bean definition?</h4>
<pre class="prettyprint"><code class="language-xml">&lt;list&gt;
    &lt;ref  bean="one" /&gt;
&lt;/list&gt;
</code></pre>
<pre class="prettyprint"><code class="language-xml">&lt;set&gt;
    &lt;ref bean="one" /&gt;
&lt;/set&gt;
</code></pre>
<pre class="prettyprint"><code class="language-xml">&lt;props&gt; &lt;!-- properties --&gt;
    &lt;prop key="a" value="b" /&gt;
&lt;/props&gt;
</code></pre>
<pre class="prettyprint"><code class="language-xml">&lt;map&gt;
    &lt;entry key="a" value="b" /&gt;
&lt;/map&gt;

&lt;!-- or --&gt;

&lt;map&gt;
    &lt;entry&gt;
        &lt;key&gt;
            &lt;value>a&lt;/value&gt;
        &lt;/key&gt;
        &lt;value&gt;b&lt;/value&gt;
    &lt;/entry&gt;
&lt;/map&gt;
</code></pre>
	<ul>
		<li>The value of a map key or value, or a set value, can also again be any of the following elements: bean | ref | idref | list | set | map | props | value | null</li>
		<li>If you need to refer to this outside a &lt;bean /&gt; or  need to specify list/set/map type, use util namespace (i.e. util:list)</li>
		<li>Use the &quot;parent&quot; attribute to inherit (and  merge entries) from a parent collection.</li>
		<li>Strongly typed collections - Entries will be converted to the appropriate  type prior to being added to the Collection</li>
	</ul>
	<h4>1.4.3 How to create an ApplicationContext? What are the resource prefixes that can be used? How to refer to a Spring configuration file inside a package? The different implementations of ApplicationContext that can be used in an application.</h4>
	<font color='blue' size="4">Creation of ApplicationContext</font>
<pre class="prettyprint"><code class="language-java">ApplicationContext ctx = new ClasspathXmlApplicationContext("one.ctx","two.ctx");</code></pre>
	<p>Supports multiple resources</p>
	<font color='blue' size="4">Prefixes</font>
	<ul>
		<li>classpath:</li>
		<li>file:</li>
		<li>http:</li>
	</ul>
	<font color='blue' size="4">Reference to configuration file</font>
<pre class="prettyprint"><code class="language-java">new ClasspathXmlApplicationContext("/com/mine/app-config.xml");</code></pre>
	<font color='blue' size="4">Implementations of ApplicationContext</font>
	<ul><strong>ClasspathXmlApplicationContext</strong>
		<li>Default prefix is classpath</li>
		<li>Starts looking from root of classpath regardless  of whether specify &quot;/&quot;</li>
	</ul>
	<ul><strong>FileSystemXmlApplicationContext</strong>
		<li>Default prefix is file</li>
		<li>Uses relative path even if specify  &quot;/&quot;, but &quot;file:/mine&quot; forces an absolute path</li>
	</ul>
	<ul><strong>XmlWebApplicationContext</strong>
		<li>Default web app (file) is /WEB-INF/applicationContext.xml</li>
		<li>Uses path relative to web application</li>
	</ul>
	<h4>1.4.4 How to externalize constants from a Spring XML configuration file  into a .properties file?</h4>
	<font color='blue' size="4">context:property-placeholder</font>
	<p>Definition/config:</p>
<pre class="prettyprint"><code class="language-xml">&lt;context:property-placeholder location="/myFile.properties" /&gt;</code></pre>
	<p>Usage in XML:</p>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="mind" class="Mine"&gt;
	&lt;property  name="a" value="${myProperty}" /&gt;
&lt;/bean&gt;</code></pre>
	<p>Usage with annotation:</p>
<pre class="prettyprint"><code class="language-java">@Value("${myProperty}")
private String value;</code></pre>
	<font color='blue' size="4">util:properties</font>
		<p>Configuration:</p>
<pre class="prettyprint"><code class="language-xml">&lt;util:properties id="myProperties" location=&quot;property file&quot; /&gt;
</code></pre>
	<p>Usage:</p>
<pre class="prettyprint"><code class="language-java">@Value("#{myProperties[myPropName]}") // specify property file and configuration item
private String myField; 

@Value("#{myPropName}") // if there is only one property file
private String myField; 
</code></pre>
	<h4>1.4.5 Purpose and usage of bean definition inheritance</h4>
      <p>Extract common bean setup into one &quot;super&quot; bean  to reduce duplicate setup code</p>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="parentBean" class="MyClass" abstract="true" /&gt;
&lt;bean id="child" parent="parentBean" class="MyDerivedClass"/&gt;
</code></pre>
	<ul>
		<li>A bean without  a class or factory is implicitly abstract.</li>
		<li>The &quot;abstract&quot; attribute is optional but good  practice as it prevents the bean from being instantiated by the container.</li>
		<li>The parent class does not have to be abstract and can  still be instantiated using the new operator.</li>
	</ul>
	<h4>1.4.6 How to use the p namespace?</h4>
	<p>Set property as attributes</p>
<pre class="prettyprint"><code class="language-xml">&lt;beans ...  xmlns:p="http://www.springframework.org/schema/p"&gt;
&lt;bean id="foo" class="x.y.Foo" 
	<strong>p:value</strong>="my value" &lt;!-- literal value --&gt;
	<strong>p:service-ref</strong>="myService"/&gt; &lt;!-- bean reference --&gt;
</code></pre>
	<h4><font color='brown'>1.4.7 Difference between &quot;id&quot; and &quot;name&quot; attributes in  the &lt;bean&gt; tag</font></h4>
	<p>Identifiers (id and/or name) must be unique within the container that hosts the bean. You are not required to supply a name or id for a bean.  If no name or id is supplied explicitly, the container generates a unique name  for that bean. However, if you want to refer to that bean by name you must  provide a name.</p>
	<ul>
		<li><strong>Id</strong> - must be unique (legal characters are limited)</li>
		<li><strong>Name</strong> - can specify multiple names separated by comma,  semicolon or space (allows more characters in name such as slashes)</li>
	</ul>
	<h4><font color='brown'>1.4.8 Purpose of the &lt;aop:scoped-proxy/&gt; tag</font></h4>
	<p>If need to inject a bean with request/session scope into  a bean with singleton scope,  the proxy  intercepts it and makes sure you get the right bean for each call. </p>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="userPref" scope="session"&gt;
	&lt;scoped-proxy/&gt;
&lt;/bean&gt;

&lt;bean ...&gt;
	&lt;property ref="userPref"/&gt;
&lt;/bean&gt;
</code></pre>
	<h4><font color='brown'>1.4.9 How does FactoryBean work (Optional, From 2.5 sample questions)?</font></h4>
	<ul>
		<li>Class name in bean definition (in xml) is that of the factory</li>
		<li>Setters called on the factory rather than the created bean</li>
		<li>Bean id maps to type returned by factory's getObject() method</li>
		<li>To get the actual FactoryBean instance from the container  and not the bean it produces, you preface the bean id with the ampersand symbol</li>
	</ul>
<pre class="prettyprint"><code class="language-java">getBean(&quot;myBean&quot;) -- returns reference of bean created by FactoryBean
getBean(&quot;&amp;myBean&quot;) -- returns reference of the FactoryBean instance itself
</code></pre>
	<h4><font color='brown'>1.4.10 How to inject using a factory method?</font></h4>
	<ul>
		<li>Instance (non-static) factory method: specify  &quot;factory-bean&quot; and &quot;factory-method&quot; attributes</li>
		<li>Static factory method: specify &quot;class&quot; and  &quot;factory-method&quot; attributes</li>
	</ul>
<pre class="prettyprint"><code class="language-xml">&lt;!-- the factory bean, which contains a method called createInstance() --&gt;
&lt;bean id="serviceLocator" class="examples.DefaultServiceLocator"&gt;
	&lt;!-- inject any dependencies required by this locator bean --&gt;
&lt;/bean&gt;

&lt;!-- the bean to be created via the factory bean --&gt;
&lt;bean id="clientService"
      factory-bean="serviceLocator"
      factory-method="createClientServiceInstance"/&gt;
</code></pre>
	<h4><font color='brown'>1.4.11 Splitting the XML</font></h4>
	<ul>
		<li>&lt;import resource=&quot;local path&quot; /&gt;, path is relative to the definition file</li>
		<li>Prefer &quot;multiple resource locations&quot; as configs are unaware of each other</li>
		<li>Use classpath:/.. or file:.. if need an absolute path</li>
	</ul>
	<h4><font color='brown'>1.4.12 Use constants in configuration</font></h4>	
	<p>XML:</p>
<pre class="prettyprint"><code class="language-xml">&lt;util:constant id="maxInt" static-field="java.lang.Integer.MAX_VALUE"/&gt;
</code></pre>
	<p>Java:</p>
<pre class="prettyprint"><code class="language-java">public class Foo {
    @Value("T(java.lang.Integer).MAX_VALUE")
    private Integer myValue;
}
</code></pre>
	<h4><font color='brown'>1.4.13 Other annotations</font></h4>
	<ul>
		<li><strong>@Scope(&quot;prototype&quot;)</strong> - to change default (singleton) scope</li>
		<li><strong>@DependsOn</strong> - beans on which the current bean depends</li>
	</ul>

	<h3>1.5 JavaConfig </h3>
	<h4>1.5.1 Usage of the @Bean and @Configuration annotations</h4>
	<p><strong>@Configuration</strong></p>
	<ul>
		<li>Declares a class to be a Spring's Java based configuration</li>
		<li>Must have default constructor or none</li>
	</ul>
	<p><strong>@Bean</strong> - declares a method as spring bean (in a Java based configuration). Properties are:</p>
	<ul>
		<li>initMethod (redundant because can call method)</li>
		<li>destroyMethod</li>
		<li>name (aliases)</li>
		<li>autowire (defaults to no)</li>
	</ul>
	<p>Other usefull annotations:</p>
	<ul>
		
		<li><strong>@Primary</strong> - indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency</li>
		<li><strong>@Import</strong> - to reference another @Configuration (you can't just call it directly as calls must be in the correct order in dependency graph)</li>
		<li><strong>@ComponentScan("com.acme.app.services")</strong> - same as &lt;context:component-scan/&gt; in XML configuration</li>
		<li><strong>@PropertySource("classpath:/com/acme/app.properties")</strong> - see example:
<pre class="prettyprint"><code class="language-java">@Configuration
@PropertySource("classpath:/com/acme/app.properties")
public class AppConfig {
    @Inject Environment env;
    @Bean
    public MyBean myBean() {
        return new MyBean(env.getProperty("bean.name"));
    }
}
</code></pre>
		</li>
	</ul>
	<h4>1.5.2 How to write a bean definition method?</h4>
<pre class="prettyprint"><code class="language-java">@Bean // Defines a String bean with the id &quot;myBean&quot; and  the value &quot;hi&quot;
public String myBean() {
	return &quot;hi&quot;;
}
</code></pre>

	<h3>1.6 Testing</h3>
	<font color='blue' size="4">Unit testing</font>
	<ul>
		<li>Mock Objects (JNDI, Servlet API, etc.)</li>
		<li>Unit Testing support Classes (ReflectionTestUtils,  ModelAndViewAssert, etc.)</li>
		<li>Isolation environment & spring configuration</li>
	</ul>
	<font color='blue' size="4">Integration testing</font>
	<ul>
		<li>To manage Spring IoC container caching (by fixture) between test execution.</li>
		<li>To provide Dependency Injection of test fixture instances.</li>
		<li>To provide transaction management appropriate to integration testing.</li>
		<li>To supply Spring-specific support classes that are useful in writing integration tests.</li>
		<li>Support for JDBC, annotations, Spring MVC, etc.</li>
	</ul>
	<h4>1.6.1 How to use Spring's integration testing support in a JUnit 4 test?</h4>
	<p>Annotations <strong>@RunWith</strong>(SpringJUnit4ClassRunner) and <strong>@ContextConfiguration</strong> provides the benefits of the TestContext framework</p>
<pre class="prettyprint"><code class="language-java"><strong>@RunWith(SpringJUnit4ClassRunner.class)</strong>
<strong>@ContextConfiguration("classpath:/META-INF/spring/hello-app-context.xml")</strong>
public class HelloServiceDefaultTest {

	@Autowired
	private HelloService service;

	@Test
	public void testSimpleProperties() throws Exception {
		assertNotNull(service);
	}
}
</code></pre>
	<p>Others:</p>
	<ul>
		<li>Annotation @ContextConfiguration uses sufix <strong>${test class}-context.xml</strong> to define default XML configuration (e.g. FooTest-context.xml for test FooTest.java) and attribute <strong>locations</strong> (e.g. locations={&quot;config.xml&quot;}) to to define more XML configurations</li>
		<li>@ContextConfiguration(</li>
		<li>@Autowire does not work on constructors</li>
		<li>The context is cached across test fixtures  unless you use @DirtiesContext (to force spring application context recreation).</li>
		<li>The &quot;inheritLocations&quot; attribute of  the annotation (default to true) inherits (appended to current list) the  super-classes locations</li>
		<li>@WebAppConfiguration - to ensure that a WebApplicationContext is loaded for your test</li>
		<li>@ContextHierarchy - to define a hierarchy of ApplicationContexts for integration tests
<pre class="prettyprint"><code class="language-java">@WebAppConfiguration
@ContextHierarchy({
    @ContextConfiguration(classes = AppConfig.class),
    @ContextConfiguration(classes = WebConfig.class)
})
public class WebIntegrationTests {
    // class body...
}
</code></pre>
		</li>
	</ul>
	<h4>1.6.2 How to declare that a test should run in a transaction in  spring-enabled JUnit 4?</h4>
	<ul>
		<li>By default, the framework will create and roll back a  transaction for each test.</li>
		<li>@TransactionConfiguration - to override default rollback policy</li>
		<li>@Transactional - on class or method, can set propagation/isolation/etc</li>
		<li>@Rollback - on class or method</li>
		<li>@BeforeTransaction (@Before is inside txn)</li>
		<li>@AfterTransaction (@After is inside txn)</li>
	</ul>
	<h4>1.6.3 Differences between a Unit test and an Integration test. Which of them is supposed to interact with Spring?</h4>
	<ul>
		<li>Unit test tests one class in isolation with mocks.</li>
		<li>Integration test tests multiple classes together.</li>
		<li>Only integration tests interact with Spring.</li>
	</ul>


	<h2>2. AOP</h2>
	<ul>
		<li>AOP is technology to solve cross-cutting concerns (authentication, logging, transacations, etc.)</li>
		<li>Spring uses AOP proxy: object created by AOP to implement the aspect contracts.</li>
		<li>The goal is to eliminate:
			<ul>
				<li><strong>Tangling</strong> - mixing of concerns</li>
				<li><strong>Scattering</strong> - code duplication</li>
			</ul>
		</li>
	</ul>
	<h3>2.1 Recommendations</h3>
	<h4>2.1.1 In order to work successfully with AOP, it is important to understand  the theory behind the scenes. Consequently you should understand the four main  AOP keywords taught in this course: Aspect, Advice, Pointcut, Joinpoint.</h4>
	<ul>
		<li>Targeted object: object being advised</li>
		<li><strong>Aspect</strong>: a modularization of a concern that cuts across multiple classes (packaged advice and pointcut).</li>
		<li><strong>Joinpoint</strong>: a point during the execution of a program (when advice is mapped to be executed), such as the execution of a method or the handling of an exception.</li>
		<li><strong>Advice</strong>: action taken by an aspect at a particular join point (code to execute).</li>
		<li><strong>Pointcut</strong>: the place in code where code can be injected (expression to identify join point). In Spring this is just before/after methods.</li>
	</ul>
	<p>MEM: For Aspect A when program reaches a Joinpoint that matches Pointcut P then execute Advice X.</p>
	
	<h3>2.2 Pointcuts</h3>
	<h4>2.2.1 You should have a deep understanding of pointcut expressions. It is important to understand all pointcut examples in the slides (apart from the ones in the &quot;advanced topics&quot; section at the end of the module).</h4>
	<ul>MEM:
		<li>Definition: <strong>execution([modifiers or annotations] ReturnType [FullyQualifiedClassName.] MethodName ([Arguments]) [throws ExceptionType])</strong></li>
		<li>Example: [public] String [a.b.c.MyClass] [doWork](String) throws RuntimeException</li>
		<li>&quot;..&quot; means 0 or more (arguments or packages)</li>
		<li>&quot;*&quot; means exactly 1 of anything (argument, package name, etc)</li>
		<li>&quot;+&quot; means this class or any implementors (no matter how deep)</li>
		<li>&amp;&amp;, ||, ! (and, or and not)</li>
		<li>Pointcut will be matched against public methods only!</li>
	</ul>
	<ul>Other expressions I think are outside the scope of the  exam:
		<li>within - certain types</li>
		<li>bean - id or name of Spring bean</li>
		<li>target - target object is an instance of the  given type</li>
		<li>this - bean ref is an instance of the given type</li>
		<li>args - args are instances of given type</li>
		<li>@target, @args, @within, @annotation .. has annotation of..</li>
	</ul>
	<p>Declaration:</p>
<pre class="prettyprint"><code class="language-java">@Pointcut(&quot;execution(* transfer(..))&quot;)  // the pointcut expression
private void anyOldTransfer() {} // the pointcut signature
</code></pre>

	<h3>2.3 Advice</h3>
	<h4>2.3.1 Different kinds of Advice. How do they differ from each other? </h4>
	<ul>
		<li>Use either <strong>ref pointcut</strong> or <strong>in-place pointcut</strong>
			<ul>
				<li>Example of ref:
<pre class="prettyprint"><code class="language-java">@Before(&quot;x.y.myOperation()&quot;)
public void handleMyOperation(){}

@Pointcut(&quot;execution(* transfer(..))&quot;)
public void myOperation(){}
</code></pre>
				</li>
				<li>Example of in-place:
<pre class="prettyprint"><code class="language-java">@Before(&quot;execution(* transfer(..))&quot;)
public void myOperation(){}
</code></pre>
				</li>
			</ul>
		</li>
		<li>Prefer least powerful advice that can do the job</li>
		<li>Declare a JoinPoint parameter to get access to methods  like: getArgs, getTarget, etc. Example of binding for of args:
<pre class="prettyprint"><code class="language-java">@Before("... && args(account,..))")
public doAdvice(Account account)
</code></pre>
		</li>
	</ul>
	<ul><strong>@Before</strong>:
		<li>Before call code </li>
		<li>Aborts if throw exception</li>
		<li>Can prevent target method being called</li>
	</ul>
	<ul><strong>@After</strong>:
		<li>After unconditionally</li>
		<li>Handles normal and exception return</li>
		<li>Can change return value or throw an exception </li>
	</ul>
	<ul><strong>@AfterReturning</strong>
		<li>After on success only </li>
		<li>Can change return value but it is not possible  to return a totally different reference when using after-returning advice.</li>
		<li>Use:
<pre class="prettyprint"><code class="language-java">@AfterReturning(pointcut="...", returning="retval") 
public void doAdvice(Object retVal)
</code></pre>
		</li>
	</ul>
	<ul><strong>@AfterThrowing</strong>:
		<li>After on failure only </li>
		<li>Can change exception type thrown</li>
		<li>Use:
<pre class="prettyprint"><code class="language-java">@AfterThrowing(pointcut=&quot;...&quot;, throwing=&quot;ex&quot;)
public void doAdvice(Exception ex)
</code></pre>
		</li>
	</ul>
	<ul><strong>@Around</strong>:
		<li>Surrounds </li>
		<li>Takes ProceedingJoinPoint, can intercept call or  ignore exception</li>
		<li>First parameter of the advice method must be of  type ProceedingJoinPoint</li>
		<li>Call proceed() on the ProceedingJoinPoint to  execute the method</li>
	</ul>

	<h3>2.4 Configuration </h3>
	<h4>2.4.1 Enabling the detection of @Aspect annotated classes. </h4>
	<p>&lt;aop:aspectj-autoproxy /&gt;</p>
	<h4>2.4.2 Is it possible to set up Spring AOP using XML configuration only (as  opposed to annotations)? </h4>
	<p>Yes.</p>
<pre class="prettyprint"><code class="language-xml">&lt;aop:config&gt;
	&lt;aop:aspect ref="adviceBean"&gt;
		&lt;aop:before pointcut="execution...." /&gt;
	&lt;/aop:aspect&gt;
&lt;/aop:config&gt;
</code></pre>

	<h3>2.5 Proxies </h3>
	<h4>2.5.1 When are they generated in the Spring lifecycle? How do they resemble the target object that they advice? What limitations does Spring-AOP's proxy-based approach have?</h4>
	<font color='blue' size="4">Proxy in Spring lifecycle</font>
	<p>They are created by Bean Post Processing.</p>
	<font color='blue' size="4">Resemblance of proxy and target object</font>
	<p>They have the same public interface if there is an interface. You must have an interface or non-final class to create a proxy.</p>
	<font color='blue' size="4">Proxy limits</font>
	<ul>
		<li>Can only be used for methods</li>
		<li>Limited pointcut syntax</li>
		<li>Doesn't get called if caller makes direct calls (due to proxy)</li>
		<li>Final classes cannot have aspects applied (proxy does not work)</li>
	</ul>
	
	<h2>!!! 3. Data Access and transactions</h2>
	<h3>3.1 General</h3>
	<h4>3.1.1 The rationale for having the DataAccessException hierarchy.</h4>
	<ul>
		<li>Runtime exception – doesn't force developers to  catch and rethrow</li>
		<li>Consistent/non-vendor specific messages –  isolates from database</li>
		<li>Clearer names – easy to catch and handle  specific errors</li>
	</ul>
	<h4>3.1.2 Definition  of a DataSource in the Spring configuration </h4>
	<ul>
		<li>JNDI:
<pre class="prettyprint"><code class="language-xml">&lt;jee:jndi-lookup id=&quot;ds&quot; jndi-name=&quot;java:comp/env/jdbc/DS&quot; /&gt;
</code></pre>
		</li>
		<li>Spring bean:
<pre class="prettyprint"><code class="language-xml">&lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt;
    &lt;property name="driverClassName" value="${jdbc.driverClassName}"/&gt;
    &lt;property name="url" value="${jdbc.url}"/&gt;
    &lt;property name="username" value="${jdbc.username}"/&gt;
    &lt;property name="password" value="${jdbc.password}"/&gt;
&lt;/bean&gt;
</code></pre>
		</li>
	</ul>
	<h3>3.2 The JdbcTemplate </h3>
	<h4>3.2.1 Usage of the JdbcTemplate with regards to exception handling </h4>
	<p>JdbcTemplate:</p>
	<ul>
		<li>Stateful – it maintains a  reference to a DataSource, but this state is not conversational state</li>
		<li>Thread-safe - once configured</li>
		<li>SQL Exception is converted to DataAccessException hierarchy</li>
		<li>Depends on datasource instance (JdbcTemplate jdbc = new JdbcTemplate(datasource);)</li>
		<li>Use NamedParameterJdbcTemplate when want param names (i.e  &quot;... where x=:myparam&quot;) rather than classic placeholder (i.e  &quot;... where x=?&quot;)</li>
		<li>Use SimpleJdbcTemplate (JDK 1.5) which delegates to  JDBCTemplate and makes use of some of the JDK 1.5 features (such as var-args)</li>
	</ul>
	<p>Spring and you:</p>
	<ul>
		<li>(You) Define  connection parameters.</li>
		<li>(Spring) Open the connection.</li>
		<li>(You) Specify the SQL statement.</li>
		<li>(You) Declare parameters and provide parameter values.</li>
		<li>(Spring) Prepare and execute the statement.</li>
		<li>(Spring) Set up  the loop to iterate through the results (if any).</li>
		<li>(You) Do the work for each iteration.</li>
		<li>(Spring) Process any exception.</li>
		<li>(Spring) Handle transactions.</li>
		<li>(Spring) Close the connection, statement and resultset.</li>
	</ul>
	<p>Key methods:</p>
	<ul>
		<li>queryForInt | queryForLong - get concreate value (&quot;select count(*) from table&quot;);</li>
		<li>queryForObject – convert to specified type </li>
		<li>queryForMap – convert to a map with the column name as key</li>
		<li>queryForList – list of maps (rows)</li>
		<li>getJdbcOperations – get interface to allow invocation of less commonly used methods</li>
	</ul>
	<p>MEM:</p>
	<ul>
		<li>RowMapper – to handle mapping of rows returned from a REF cursor</li>
		<li>RowCallbackHandler – when we need to write out data to file but not return it</li>
		<li>ResultSetExtractor – extracts values from each row of a ResultSet into one entity</li>
	</ul>

	<p>Examples of data querying:</p>
<pre class="prettyprint"><code class="language-java">// querying with parameters
jdbc.queryFor____(String sql, Object[] args)
jdbc.queryFor____("select count(*) from table where  col > ? and col < ?", new Object[] {10, 2}); 
jdbc.queryFor____(String sql, Object... args) 


// usage of mapping entity
RowMapper<A> mapper = new RowMapper<A>() {
    public A  mapRow(ResultSet rs, int row) throws SQLException {...}
};
jdbc.query(sql, mapper); // use with query (generally for a list)
jdbc.queryForObject(sql, mapper); // load a single entity


// usage of writting out data
RowCallbackHandler handler = new RowCallbackHandler() {
    public void  processRow(ResultSet rs) {...}
};
jdbc.query(sql, handler);


// usage of mapping resultset into entity
ResultSetExtractor<A> extractor = new  ResultSetExtractor<A>() {
    public A extractData(ResultSet rs) {...};
};
jdbc.query(sql,  extractor);
</code></pre>
	<p>Examples of special operations:</p>
<pre class="prettyprint"><code class="language-java">// querying for DML (insert/update/delete row)
jdbc.update(sql);
jdbc.update(PreparedStatementCreator, KeyHolder)


// executing DDL
jdbc.execute(sql);


// executing batch update
BatchPreparedStatementSetter setter = new  BatchPreparedStatementSetter() {
    public void  setValues(PreparedStatement stmt, int row) {}
    public int  getBatchSize() { return 0; }
}
jdbcTemplate.batchUpdate(sql, setter); // or pass  Object[] as second parameter
</code></pre>

	<h3>3.3 Hibernate</h3>
	<h4>3.3.1 Configuration of a SessionFactoryBean in xml</h4>
	<p>Instances:</p>
	<ul>
		<li><strong>LocalSessionFactoryBean</strong> - supports a list of Hibernate XML  mapping locations (use mappingLocations).
<pre class="prettyprint"><code class="language-xml">&lt;bean id="sf" class="os.orm.hibernate3.LocalSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="d" /&gt;
    &lt;property name="mappingLocations"&gt;
        &lt;list&gt;
            &lt;value&gt;classpath:/package/hbm.xml&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property>
&lt;/bean> 
</code></pre>
		</li>
		<li><strong>AnnotationSessionFactoryBean</strong> - extends LocalSessionFactoryBean and adds support
			<ul>
				<li><strong>annotatedClasses</strong> - for a list of annotated classes (wildcards are not supported)</li>
				<li><strong>packagesToScan</strong> - for packages to scan</li>
			</ul>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="sf" class="os.orm.hibernate3.annotation.AnnotationSessionFactoryBean"&gt;
    &lt;property name="dataSource" ref="d" /&gt;
    &lt;property name="annotatedClasses"&gt;
        &lt;list&gt;
            &lt;value&gt;Class1&lt;/value&gt;
            &lt;value&gt;Class2&lt;/value&gt;
        &lt;/list&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
		</li>
	</ul>
	<p>Read only transactions prevent Hibernate from flushing session.</p>

	
	<h3>3.4 Transactions </h3>
	<h4>3.4.1 Configuration to declare a local transaction manager</h4>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="mgr" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt;
    &lt;property  name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;
</code></pre>
	<ul>
		<li><strong>HibernateTransactionManager</strong> - supports Hibernate and JDBC</li>
		<li><strong>JdbcTransactionManager</strong> - only supports JDBC</li>
		<li><strong>JpaTransactionManager</strong> - supports JPA and JDBC</li>
		<li>etc.</li>
	</ul>
	<h4>3.4.2 Configuration to declare a JTA transaction manager</h4>
<pre class="prettyprint"><code class="language-xml">&lt;bean id=&quot;mgr&quot; class=&quot;org.springframework.transaction.jta.JtaTransactionManager&quot;&gt;
    &lt;property  name="dataSource" ref="dataSource"/&gt;
&lt;/bean&gt;
</code></pre>
	<p>or</p>
<pre class="prettyprint"><code class="language-xml">&lt;tx:jta-transaction-manager /&gt;
</code></pre>
	<h4>3.4.3 The different ways to do declarative transaction management with Spring (xml, annotations)</h4>
    <p>We have to define transaction manager first (see previous chapters).</p>
	<font color='blue' size="4">XML</font>
<pre class="prettyprint"><code class="language-xml">&lt;aop:config&gt;
    &lt;aop:advisor  pointcut-ref="p" advice-ref="ta" /&gt;
&lt;/aop:config&gt;

&lt;tx:advice  id="ta"&gt;
    &lt;tx:attributes&gt;
        &lt;tx:method name="update*" timeout="60" /&gt;
        &lt;tx:method name="*" timeout="30"  read-only="true" /&gt;
    &lt;/tx:attributes&gt;
&lt;/tx:advice&gt;
</code></pre>
	<font color='blue' size="4">Annotations</font>
	<p>Use annotation <strong>@Transactional</strong> as:</p>
	<ul>
		<li>applicable on public methods or class</li>
		<li>not applicable on non-public methods - there will be no error, but no transaction will be applied</li>
		<li>not recommend on interfaces b/c not all proxies will take them</li>
	</ul>
	<h4>3.4.4 Usage of TransactionTemplate for programmatic transaction management  (you simply need to understand a basic example based on the TransactionTemplate).</h4>
	<ul>
		<li>Takes transaction manager in constructor</li>
		<li>Passes TransactionStatus to TransactionCallback which lets you call status.setRollbackOnly()</li>
	</ul>
	<p>Example:</p>
<pre class="prettyprint"><code class="language-java">public Object  someServiceMethod() {
    return  transactionTemplate.execute(new TransactionCallback() {
        public Object  doInTransaction(TransactionStatus status) {
            updateOperation1();
            return  resultOfUpdateOperation2();
        }
    });
}
</code></pre>
	<h4>3.4.5 Transactions and exception management: what is the default rollback policy? Can it be overridden?</h4>
	<ul>
		<li>Default policy is rollback for a RuntimeException.</li>
		<li>Default policy can be overriden - for the @Transactional annotation, specify <strong>rollbackFor</strong> or <strong>noRollbackFor</strong> when passing Class or rollbackForClassname/noRollbackForClassname when passing Strings.</li>
	</ul>
	<h4>3.4.6 The @Transactional annotation: what are the main attributes that can be used for a transaction definition? Can this annotation also be used with a JTA Transaction Manager?</h4>
	<p>Main attributes of @Transactional annotation are:</p>
	<ul>
		<li><strong>timeout</strong> - specified in seconds</li>
		<li><strong>readOnly</strong> - true or false</li>
		<li><strong>isolation</strong> - Isolation.READ_UNCOMMITTED, READ_COMMITTED,  REPEATABLE_READ or SERIALIZABLE</li>
		<li><strong>propagation</strong> - Propagation.REQUIRES_NEW, REQUIRED, etc.</li>
		<li><strong>rollbackFor</strong> or <strong>rollbackForClassname</strong> - list of exceptions</li>
		<li><strong>noRollbackFor</strong> or <strong>noRollbackForClassname</strong> - list of exceptions</li>
	</ul>
    <p>Yes, @Transactional annotation can be used with JTA Transaction Manager.</p>

	<h4>3.4.7 Regarding propagation modes, what is the difference between PROPAGATION_REQUIRED and PROPAGATION_REQUIRES_NEW</h4>
	<p>Main attributes of @Transactional annotation are:</p>
	<ul>
		<li><strong>REQUIRED</strong> (default) - If there’s an existing transaction in progress,  the current method should run within this transaction. Otherwise, it should start a new transaction and  run within its own transaction.</li>
		<li><strong>REQUIRES_NEW</strong> - The current method must start a new transaction  and run within its own transaction. If there’s an existing transaction in progress,  it should be suspended.</li>
		<li><strong>SUPPORTS</strong> - If there’s an existing transaction in progress,  the current method can run within this transaction. Otherwise, it is not necessary to run within a  transaction.</li>
		<li><strong>NOT_SUPPORTED</strong> - The current method should not run within a  transaction. If there’s an existing transaction in progress,  it should be suspended.</li>
		<li><strong>MANDATORY</strong> - The current method must run within a  transaction. If there’s no existing transaction in progress,  an exception will be thrown.</li>
		<li><strong>NEVER</strong> - The current method should not run within a  transaction. If there’s an existing transaction in progress,  an exception will be thrown.</li>
		<li><strong>NESTED</strong> (unique Spring feature) - If there’s an existing transaction in progress,  the current method should run within the nested transaction (supported by the  JDBC 3.0 save point feature) of this transaction. Otherwise, it should start a new transaction and  run within its own transaction.</li>
	</ul>
	<p>MEM: If methodA calls methodB directly, the transaction  attributes of methodB are NOT used (due to proxy issue).</p>

	<h4>3.4.8 Regarding isolation levels, what is the difference between  READ_COMMITTED and READ_UNCOMMITTED?</h4>
	<p>Read phenomena:</p>
	<ul>
		<li>
			<strong>Dirty reads</strong> (Uncommitted Dependency) - A dirty read occurs when a transaction is allowed to read data from a row that has been modified by another running transaction and not yet committed.
			<ul>
				<li>T1 Read</li>
				<li>T2 Update</li>
				<li>T1 Read  will be temporary and invalid.</li>
				<li>T2 Rollback</li>
			</ul>
		</li>
		<li>
			<strong>Nonrepeatable read</strong> - A non-repeatable read occurs, when during the course of a transaction, a row is retrieved twice and the values within the row differ between reads.
			<ul>
				<li>T1 Read</li>
				<li>T2 Update</li>
				<li>T1 Read  value will be different</li>
			</ul>
		</li>
		<li>
			<strong>Phantom read</strong> - A phantom read occurs when, in the course of a transaction, two identical queries are executed, and the collection of rows returned by the second query is different from the first.
			<ul>
				<li>T1 Read</li>
				<li>T2 Insert</li>
				<li>T1 Read  will contain additional rows.</li>
			</ul>
		</li>
	</ul>
	<p>The options to solve the read phenomena are:</p>
	<ul>
		<li><strong>DEFAULT</strong> - Uses the default isolation level of the underlying database. For most databases, the default isolation level is READ_COMMITTED.</li>
		<li><strong>READ_UNCOMMITTED</strong> - Allows a transaction to read uncommitted changes by other transactions. The dirty read, nonrepeatable read, and phantom read problems may occur.</li>
		<li><strong>READ_COMMITTED</strong> - Allows a transaction to read only those changes that have been committed by other  transactions. The dirty read problem can be avoided, but the nonrepeatable read and phantom read  problems may still occur.</li>
		<li><strong>REPEATABLE_READ</strong> - Ensures that a transaction can read identical values from a field multiple times. For the duration of this transaction, updates made by other transactions to this field are  prohibited. The dirty read and nonrepeatable read problems can be avoided, but the phantom read  problem may still occur.</li>
		<li><strong>SERIALIZABLE</strong> - Ensures that a transaction can read identical rows from a table multiple times. For the duration of this transaction, inserts, updates, and deletes made by other transactions to this table are prohibited. All the  concurrency problems can be avoided, but the performance will be low.</li>
	</ul>
	
	<h2>!!! 4. Spring MVC</h2>
	<h3>4.1 General configuration </h3>
	<ul>
		<li>&lt;mvc:annotation-driven /&gt; - Registers the DefaultAnnotationHandlerMapping  and AnnotationMethodHandlerAdapter beans that are required for Spring MVC to dispatch requests to @Controllers.</li>
		<li>&lt;context:component-scan /&gt; - To enable autodetection of such annotated controllers (as well as other stereotype  components)..</li>
	</ul>
	
	<h4>4.1.1  This module shows how to configure a ViewResolver, a HandlerMapping and the DispatcherServlet. You won't be asked any question on how to configure those classes. However, you need to know what the goal of each of those components is.</h4>
	<font color='blue' size="4">View Resolver</font>
	<ul>
		<li>Identifies correct view to call (to resolve the view implementation based on given logical name). All handler methods in the Spring Web MVC controllers must resolve to a logical view name. View resolver can not handle absolute path (of view).</li>
		<li>Explicitly (e.g., by returning a String, View or ModelAndView). They can also return null/void (to use default view) or a concrete class such as new JstlView(path)</li>
		<li>Implicitly (i.e., based on conventions)</li>
	</ul>
	<p>Some of implementations:</p>
	<ul>
		<li>AbstractCachingViewResolver - caches view</li>
		<li>XMLViewResolver - mapping config from xml file</li>
		<li>ResourceBundleViewResolver - mapping from  property bundle file</li>
		<li>UrlBasedViewResolver - maps urls directly to  views</li>
		<li>InternalResourceViewResolver - extends  UrlBasedViewResolver, maps to servlets / jsps</li>
		<li>FreeMarkerViewResolver - extends  UrlBasedViewResolver</li>
		<li>ContentNegotiatingViewResolver - maps based on  request file name or Accept header   </li>
	</ul>
	<p>Usage:</p>
	<ul>
		<li>Can be chained (using the &quot;order&quot; attribute). InternalResourceViewResolver must be last.</li>
		<li>RedirectView or &quot;redirect:&quot;</li>
	</ul>
	<font color='blue' size="4">Handler Mapping</font>
	<ul>
		<li>Identifies correct controller to call.</li>
		<li>Spring 3 uses the default one which goes by the @RequestMapping annotation defined in the @Controller. Can be overriden (in xml) if required</li>
	</ul>
	<font color='blue' size="4">Dispatch Servlet</font>
	<ul>
		<li>Front controller delegating to web infrastructure beans (handler mappings, view resolvers, type converters) and calling controllers/views</li>
		<li>Scenario of handling request:
			<ol>
				<li>Handler Mapping(Request) returns Controller</li>
				<li>Controller(Request) returns ModelAndView</li>
				<li>View Resolver(View Name) returns View</li>
				<li>View(Model) returns Response</li>
				<li>returns  Response</li>
			</ol>
		</li>
	</ul>
	<h4>4.1.2 You also need to understand the relationship between a DispatcherServlet ApplicationContext and a root ApplicationContext.</h4>
	<ul>
		<li>DispatcherServletApplicationContext can see the root context's configuration, but the root context can not see DispatchServletApplicationContext.</li>
		<li>DispatchServletApplicationContext can override root context beans</li>
	</ul>

	<h3>4.2 Controllers </h3>
	<h4>4.2.1 Bootstrapping a root WebApplicationContext using the ContextLoaderListener</h4>
      <p>The <strong>DispatcherServlet</strong> takes a contextConfigLocation  parameter in the web.xml or uses the default of <strong>${servlet_name}-servlet.xml</strong>. We need (to configure DispatcherServlet properly) to do:</p>
	<ul>
		<li>Define listener so it loads the root ApplicationContext before initializing the servlet as:
<pre class="prettyprint"><code class="language-xml">&lt;listener&gt;
    &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;
&lt;/listener&gt;
</code></pre>
		</li>
		<li>Define servlet as:
<pre class="prettyprint"><code class="language-xml">&lt;servlet&gt;
	&lt;servlet-name&gt;mvc-dispatcher&lt;/servlet-name&gt;
	&lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;
	&lt;load-on-startup&gt;1&lt;/load-on-startup&gt;
&lt;/servlet&gt;

&lt;servlet-mapping&gt;
	...
&lt;/servlet-mapping&gt;
</code></pre>
		</li>
		<li>Default configuration file is <strong>/WEB-INF/applicationContext.xml</strong> or it can be overriden by:
<pre class="prettyprint"><code class="language-xml">&lt;context-param&gt;
    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;
    &lt;param-value&gt;/WEB-INF/court-service.xml&lt;/param-value&gt;
&lt;/context-param&gt;
</code></pre>
		</li>
	</ul>
	<h4>4.2.2 General usage of the @Controller and @RequestMapping annotations</h4>
	<ul>
		<li><strong>@Controller</strong> - annotates a class containing @RequestMapping on methods  returning ModelAndView, String, void, etc.</li>
		<li><strong>@RequestMapping</strong>:
			<ul>
				<li>Takes value of path of URL to match on method level and optionally class level adding slashes as needed.</li>
				<li>Combined, they form the absolute URL path including Ant style wildcards.</li>
				<li>Can also restrict by type or filter by params/headers (e.g. method=RequestMethod.GET)</li>
				<li>You can declare @RequestMapping on both the class/method  level or just the method level. The method level is key because it tells Spring  the method can handle requests.</li>
			</ul>
		</li>
	</ul>
	<p>Example of mapping &quot;/appointments/new&quot; to getNewForm() (for only GET):</p>
<pre class="prettyprint"><code class="language-java">@Conttroller
@RequestMapping("/appointments")                              
public class  AppointmentsController {...
    @RequestMapping(value="/new", method =  RequestMethod.GET)
    public  AppointmentForm getNewForm() {...}
}
</code></pre>
	<font color='blue' size="4">URI Template</font>
	<ul>
		<li>Ant syle globs:  @RequestMapping(&quot;/myPath/*/pets/{petId}&quot;)</li>
		<li>Parameter conditions: @RequestMapping(value =  &quot;/pets/{petId}&quot;, params=&quot;myParam=myValue&quot;)</li>
		<li>Header conditions: @RequestMapping(value =  &quot;/pets&quot;, method = RequestMethod.POST,  headers=&quot;content-type=text/*&quot;)</li>
	</ul>
<pre class="prettyprint"><code class="language-java">@RequestMapping(value="/owners/{ownerId}",  method=RequestMethod.GET)
public String findOwner(@PathVariable("ownerId")  String ownerId, Model model) {
</code></pre>
	<h4>4.2.3 A method annotated with @RequestMapping can return a String. What does it refer to? What are the main parameter types that this method can accept? (based  on what you've seen in the class)</h4>
	<ul>
		<li>A method annotated with @RequestMapping returns: the view name - i.e. logical name of the view (to be deteremined by view resolver). For example, one can add a prefix/suffix to all strings returned, void (if the method handles the response directly), etc.</li>
		<li>Main parameter types of @RequestMapping method:
			<ul>
				<li><strong>Servlet API</strong> - HttpSession, HttpServletRequest,  HttpServletResponse</li>
				<li><strong>Stream</strong> - InputStream, Reader, OutputStream, Writer</li>
				<li><strong>Annotated</strong> - @PathVariable, @RequestParam, @RequestHeader,  @RequestBody</li>
				<li><strong>Model</strong> - Map, Model, ModelMap</li>
				<li><strong>Other</strong> - Command or Form objects, Errors, SessionStatus</li>
			</ul>
		</li>
	</ul>
	<p>MEM: Method can not return absolute path to view.</p>
	<h4>4.2.4 Goal of the @RequestParam annotation</h4>
	<ul>
		<li>To map request parameters to method parameters for use in the controller's methods.</li>
		<li>Can pass parameter name if doesn't match one in method.</li>
	</ul>
<pre class="prettyprint"><code class="language-java">@RequestMapping(method=RequestMethod.GET)
public String findOwner(@RequestParam("ownerId")  String ownerId, Model model) {
</code></pre>
	<h4><font color='brown'>4.2.x-1 Configuring Spring MVC via XML</font></h4>
<pre class="prettyprint"><code class="language-xml">&lt;mvc:annotation-driven /&gt;
&lt;mvc:interceptors  /&gt;
</code></pre>
	<h4><font color='brown'>4.2.x-2 Does Spring handle Multipart request?</font></h4>
	<p>Yes</p>
	<ul>
		<li>If you specify a multipart file resolver, the request is  inspected for multiparts.</li>
		<li>If multiparts are found, the request is wrapped in a  MultipartHttpServletRequest for further processing by other elements in the process.</li>
		<li>In the controller, use:  @RequestParam(&quot;myParam&quot;) MultipartFile file</li>
	</ul>
	<h3><font color='brown'>4.3 REST</font></h3>
	<h4><font color='brown'>4.3.1 Differences between GET, POST, PUT and DELETE</font></h4>
	<p>@RequestMapping defines URI to resource, action (what to do with the resource) is defined by HTTP method:</p>
	<ul>
		<li>GET = select (read only)</li>
		<li>POST = create</li>
		<li>PUT = update</li>
		<li>DELETE = delete</li>
	</ul>
	<h4><font color='brown'>4.3.2 Usage of the @PathVariable annotation</font></h4>
	<p>Maps parts of the url in @RequestMapping to a  parameter. For example the URL /account/{id} goes with @PathVariable id in the method signature. See URI template in chapter 4.2.2</p>
	<h4><font color='brown'>4.3.3 What is the RestTemplate?</font></h4>
	<p>Programmatic client for calling RESTful URLs.</p>
<pre class="prettyprint"><code class="language-java">String result =  restTemplate.getForObject(&quot;http://example.com/hotels/{hotel}/bookings/{booking}&quot;, String.class,&quot;42&quot;, &quot;21&quot;);
RestTemplate t = new RestTemplate();
t.getForObject(uri, MyResponse.class, id);
t.postForObject(url, request, MyResponse.class, var1,  var2) or t.postForLocation(url, request, var1, var2)
t.put(uri, mine);
t.delete(uri);
</code></pre>
	<h4><font color='brown'>4.3.4 Purpose of the @ResponseStatus Annotation</font></h4>
	<ul>
		<li>Send an HTTP response code with the response. For example, @ResponseStatus(HttpStatus.CREATED).</li>
		<li>If defined on the method, sends that header.</li>
		<li>If defined on an exception, only sends if that error occurs.</li>
		<li>An empty body can be used for REST so no view is used.</li>
		<li>Annotation can go on @RequestMapping method or an exception class.</li>
	</ul>
	<h4><font color='brown'>4.3.5 Purpose of the @ExceptionHandler Annotation</font></h4>
	<ul>
		<li>Specify which method is invoked when an exception of a specific type is thrown during the execution of controller methods</li>
		<li>If cannot annotate the actual exception, defines a response status in controller.</li>
	</ul>
	<p>For example:</p>
	<ul>
		<li>@ResponseStatus(HttpStatus.NOT_FOUND)</li>
		<li>@ExceptionHandler({MyException.class})</li>
	</ul>
	<h4><font color='brown'>4.3.6 What are HttpMessageConverters?</font></h4>
	<ul>
		<li>HttpMessageConverter to convert to / from HTTP</li>
		<li>Objects passed to and returned from the methods getForObject(), postForLocation(), and put() are converted to HTTP requests and  from HTTP responses by HttpMessageConverters.</li>
		<li>Concrete implementations for the main media (mime) types  are provided in the framework and are registered by default with the  RestTemplate on the client-side and with AnnotationMethodHandlerAdapter on the  server-side.</li>
		<li>Use @RequestBody to map params, use @ResponseBody to map return value</li>
	</ul>

	<h2>!!! 5. Advanced topics </h2>
	<h3>5.1 Remoting </h3>
	<h4>5.1.1 Advantages of using Spring Remoting rather than plain RMI?</h4>
	<ul>
		<li>Hide plumbing/complexity</li>
		<li>Support multiple protocols</li>
		<li>Simplify things when both ends of remote call run Spring</li>
	</ul>
	<h4>5.1.2 Goal and general configuration of the RMI Service Exporter</h4>
	<p>Goals:</p>
	<ul>
		<li>Handle server side of RMI interaction</li>
		<li>Bind to registry</li>
		<li>Expose endpoint (used for everything except EJB; EJB  already has mechanism to export remote)</li>
	</ul>
	<p>General configuration:<br>
<pre class="prettyprint"><code class="language-xml">&lt;bean class="org.springframework.remoting.rmi.RmiServiceExporter"&gt;
    &lt;property name="serviceName" value="AccountService"/&gt; &lt;!-- name in registry --&gt;
    &lt;property name="service" ref="accountService"/&gt; &lt;!-- reference to POJO implementing  serviceInterface --&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt; &lt;!-- interface classname --&gt;
    &lt;property name="registryPort" value="1199"/&gt; &lt;!-- defaults to 1099 --&gt;
&lt;/bean&gt;
</code></pre>
	<h4>5.1.3 Goal and general configuration of RMI Proxy Generator</h4>
	<p>Goals:</p>
	<ul>
		<li>Handle client side of RMI interaction</li>
		<li>Communicate with endpoint</li>
		<li>Convert remote exception to runtime exception</li>
		<li>Can treat remote EJBs as POJOs</li>
	</ul>
	<p>General configuration:<br>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="accountService" class="org.springframework.remoting.rmi.RmiProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="rmi://HOST:1199/AccountService"/&gt; &lt;!-- endpoint in registry (rmi://server:port/serviceName) --&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt; &lt;!-- interface classname --&gt;
&lt;/bean&gt;
</code></pre>
	<h4>5.1.4 Difference between the RMI Service Exporter and the HttpInvoker</h4>
	<ul>
		<li>HttpInvoker uses HTTP POST while RMI one uses RMI.</li>
		<li>Bean classes to expose bean are HttpInvokerServiceExporter or RmiServiceExporter with the definition of service (reference to POJO implementing serviceInterface) and service interface  (interface classname).</li>
		<li>Bean classes to connect bean are HttpInvokerProxyFactoryBean or RmiProxyFactoryBean with the definition of service URL (endpoint to the bean) and service interface  (interface classname).</li>
		<li>The serviceName is specified as the name of the bean because default is to use BeanNameUrlHandlerMapping.</li>		
	</ul>
<pre class="prettyprint"><code class="language-xml">&lt;bean name="/AccountService" class="org.springframework.remoting.httpinvoker.HttpInvokerServiceExporter"&gt;
    &lt;property name="service" ref="accountService"/&gt; &lt;!-- reference to POJO implementing  serviceInterface --&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt; &lt;!-- interface classname --&gt;
&lt;/bean&gt;
</code></pre>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="httpInvokerProxy" class="org.springframework.remoting.httpinvoker.HttpInvokerProxyFactoryBean"&gt;
    &lt;property name="serviceUrl" value="http://remotehost:8080/remoting/AccountService"/&gt;
    &lt;property name="serviceInterface" value="example.AccountService"/&gt; &lt;!-- interface classname --&gt;
&lt;/bean&gt;
</code></pre>
	<h4>5.1.7 Does the HttpInvoker require to run a web server on the client side?  On the server side?</h4>
	<p>Hessian (Caucho's binary-based format), Burlap (Caucho's XML-based format), HttpInvoker (spring's binary-based format) need a web server on the  server side, but not on the client side.</p>

	<h3>5.2 Security</h3>
	<p>Basic concepts:</p>
	<ul>
		<li><strong>Authentication</strong> is the process of verifying a principal's identity against what it claims to be.</li>
		<li>A <strong>principal</strong> can be a user, a device or a system, but most typically, it's a user. </li>
		<li>A principal has to provide evidence of identity to be authenticated. </li>
		<li>This evidence is called a <strong>credential</strong>, which is usually a password when the target principal is a user.</li>
		<li><strong>Authorization</strong> is the process of granting <strong>authorities</strong> to an authenticated user so that this user is allowed to access particular resources.</li>
		<li>The authorization process must be performed after the authentication process.</li>
		<li>Typically, authorities are granted in terms of roles.</li>
		<li><strong>Access control</strong> means controlling access to an application's resources.</li>
		<li>It entails making a decision on whether a user is allowed to access a resource.</li>
		<li>This decision is called an access control decision, and it's made by comparing the resource's access attributes with the user's granted authorities or other characteristics.</li>
	</ul>
      <p>Security is activated in web.xml:</p>
<pre class="prettyprint"><code class="language-xml">&lt;filter&gt;
    &lt;filter-name&gt;springSecurityFilterChain&lt;/filter-name&gt;
    &lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;/filter-class&gt;
&lt;/filter&gt;
</code></pre>
      <p>Auto-config includes:</p>
<pre class="prettyprint"><code class="language-xml">&lt;http&gt;
    &lt;form-login /&gt;
    &lt;http-basic /&gt;
    &lt;logout /&gt;
&lt;/http>
</code></pre>
	<ul>
		<li>Use &lt;form-login /&gt; to set: login-pages, default-target-url,  authentication-failure-url</li>
		<li>Use &lt;logout /&gt; to set:  logout-success-url</li>
		<li>Use &lt;anonymous username=&quot;guest&quot;  granted-authority=&quot;ROLE_GUEST&quot; /&gt; to setup the anonymous user</li>
		<li>Use &lt;remember-me /&gt; to setup Remember-Me Support</li>
	</ul>

	<h4>5.2.1 What is the &quot;Security filter chain&quot; used in Spring Security?</h4>
	<p>Series of servlet filters (filter chain) that must be passed before/after resource is accessed. The chain is declared in web.xml (as servlet filter) and consists of:</p>
	<ul>
		<li><strong>HttpSessionContextIntegrationFilter</strong> - loading HttpSession's context </li>
		<li><strong>LogoutFilter</strong> - logging out if needed (logout was triggered)</li>
		<li><strong>AuthenticationProcessingFilter</strong> - authenticating if needed</li>
		<li><strong>ExceptionTranslationFilter</strong> - throwing proper exception (after only) </li>
		<li><strong>FilterSecurityInterceptor</strong> - checking role (authorization)</li>
	</ul>
	<h4>5.2.2 Syntax to configure Spring Security to intercept particular URLs? (you need to have a good understanding of the various examples using intercept-url in the course)</h4>
<pre class="prettyprint"><code class="language-xml">&lt;security:http&gt;
    &lt;security:intercept-url pattern="/stuff/**"  [method="GET"] access="role1, role2" /&gt;
&lt;/security:http&gt;
</code></pre>
	<ul><strong><font color="red">Check againt training materials!</font></strong>
		<li>Always end url with a &quot;*&quot; to prevent hackers skipping the check by adding extra request parameters</li>
		<li>Pattern uses Ant syntax (** is any level of directories), can change to reg exp</li>
		<li>Access can get IS_AUTHENTICATED_FULLY or a list of roles</li>
		<li>If more than one intercept-url, matched top to bottom</li>
		<li>filters=&quot;none&quot; - no security applied</li>
		<li>Anonymous users have the ROLE_ANONYMOUS role</li>
	</ul>
	<h4>5.2.3 Syntax to configure method level security</h4>
	<strong><font color="red">Check againt training materials!</font></strong>
	<h4>5.2.4 Method level security using @Secured or @RolesAllowed</h4>
	<ul>
		<li>Spring
			<ul>
				<li>XML activation - &lt;security:global-method-security <strong>secured-annotations</strong>=&quot;enabled&quot; /&gt;</li>
				<li>Usage - <strong>@Secured</strong>(&quot;role1&quot;) to pass allowed roles</li>
			</ul>
		</li>
		<li>JSR-250
			<ul>
				<li>XML activation - &lt;security:global-method-security <strong>jsr250-annotations</strong>=&quot;enabled&quot; /&gt;</li>
				<li>Usage - <strong>@RolesAllowed</strong>(&quot;role1&quot;) to pass allowed roles</li>
			</ul>
		</li>
		<li>Without annotations:
<pre class="prettyprint"><code class="language-xml">&lt;security:global-method-security&gt;
    &lt;security:protect-pointcut expression="execution(*  doStuff())" access="role" /&gt;
&lt;/security:global-method-security&gt;
</code></pre>
		</li>
		<li>Secure a bean with a list of method names using:
<pre class="prettyprint"><code class="language-xml">&lt;bean  id="..." &gt;
    &lt;security:intercept-methods&gt;
        &lt;security:protect  method="com.apress.springrecipes.board.service.MessageBoardService.listMessages" access="ROLE_USER,ROLE_GUEST" /&gt;
    &lt;/security:intercept-methods&gt;
&lt;/bean&gt;
</code></pre>
		</li>
	</ul>
	<h4>5.2.5 Possible mechanisms to store user details: database? LDAP? Others?</h4>
	<ul>
		<li>Database: &lt;security:jdbc-user-service data-source-ref=&quot;ds&quot; /&gt;</li>
		<li>In memory: &lt;security:user-service properties=&quot;a.properties&quot; /&gt;</li>
		<li>xml or properties files</li>
		<li>LDAP, JAAS, SSO, OpenId, etc.</li>
	</ul>	  
	<p>Example:</p>
<pre class="prettyprint"><code class="language-xml">&lt;authentication-manager&gt;
    &lt;authentication-provider&gt;
        &lt;user-service&gt;
            &lt;user name="jimi" password="jimispassword" authorities="ROLE_USER, ROLE_ADMIN" /&gt;
            &lt;user name="bob" password="bobspassword" authorities="ROLE_USER" /&gt;
        &lt;/user-service&gt;
    &lt;/authentication-provider&gt;
&lt;/authentication-manager&gt;
</code></pre>
	<h4>5.2.7. When working with an authentication provider, is it possible to use  a password encoder?</h4>
	<p>Yes - &lt;security:password-encoder hash=&quot;abc&quot; /&gt;</p>
      <h4>5.2.8 In the security tag library, what is the purpose of the  &lt;security:authorize /&gt; tag?</h4>
      <p>To say what roles are permitted access to a section of the JSP.</p>
<pre class="prettyprint"><code class="language-xml">&lt;security:authorize access=&quot;hasRole('supervisor')&quot;&gt;do stuff&lt;/security:authorize&gt;
&lt;security:authorize ifAnyGranted=&quot;roles&quot;&gt;do stuff&lt;/security:authorize&gt;
</code></pre>
	<p>Possible properties:</p>
	<ul><strong><font color="red">Check againt training materials!</font></strong>
		<li>access</li>
		<li>url</li>
		<li>ifAnyGranted</li>
		<li>ifAllGranted</li>
	</ul>

	<h3>5.3 JMS</h3>
	<font color='blue' size="4">JmsTemplate</font>
	<ul>
		<li>Instances of the JmsTemplate class are thread-safe once configured.</li>
		<li>All send methods put message on queue and resume.</li>
		<li>All receive methods are blocking / synchronous.</li>
		<li>MessagePostProcessor interface gives you access to the message after it has been converted.</li>
		<li>Properties:
			<ul>
				<li>Connection Factory (e.g. SingleConnectionFactory or CachingConnectionFactory - required</li>
				<li>Use &quot;defaultDestination&quot; (destination does not need to be specified for each send / receive call) - Spring bean (reference name) or DestinationResolver.</li>
			</ul>
		</li>
		<li>Methods (use MessageCreator - if need to map object to/from Message for nonstandard type):
			<ul>
				<li>&quot;convertAndSend()&quot; - delegates conversion to the MessageConverter bean (set on the JmsTemplate) and then sends message</li>
				<li>&quot;convertAndSend()&quot; - waits to receive message and then delegates to the MessageConverter bean (set on the JmsTemplate).</li>
				<li>&quot;execute()&quot; - use for SessionCallback and ProducerCallback</li>
				<li>No callback methods exist.</li>
			</ul>
<pre class="prettyprint"><code class="language-java">jmsTemplate.send(this.queue, new MessageCreator() {
    public  Message createMessage(Session session) throws JMSException {
            return  session.createTextMessage("hello queue world");
    }
});
</code></pre>
		</li>
		<li>Configuration:
			<ul>
				<li>Create connection factory and queues by creating bean for standalone or &lt;jee:jndi-lookup jndi-name=&quot;jms/aaa&quot; /&gt;</li>
				<li>Can wrap with CachingConnectionFactory if need caching</li>
			</ul>
		</li>
	</ul>
	<h4>5.3.1 Purpose of the JmsTemplate</h4>
	<ul>
		<li>Simplify usage of JMS</li>
		<li>Reduce boilerplate code</li>
		<li>Handle  exceptions</li>
		<li>etc.</li>
	</ul>
	<h4>5.3.2 How to declare a JMS Listener? Can a JMS Listener be a POJO?</h4>
	<font color='blue' size="4">Declaration of the JMS Listener</font>
	<ul>
		<li>Use Message-Driven POJOs (which must be thread-safe)</li>
		<li>Implement javax.jms.MessageListener (JavaEE) or SessionAwareMessageListener (Spring-specific)</li>
		<li>Use the MessageListenerAdapter class (as spring bean), e.g.:
<pre class="prettyprint"><code class="language-xml">&lt;bean id="messageListener" class="org.springframework.jms.listener.adapter.MessageListenerAdapter"&gt;
    &lt;constructor-arg&gt;
        &lt;bean class="MyDelegate"/&gt;
    &lt;/constructor-arg&gt;
&lt;/bean&gt;
</code></pre>
		</li>
		<li>Define a container
<pre class="prettyprint"><code class="language-xml">&lt;jms:listener-container connection-factory="connFactoryRef"&gt;
    &lt;jms:listener destination="d" ref="myDelegate" /&gt;
&lt;/jms:listener-container&gt;
</code></pre>
		</li>
		<li>Extend JmsGatewaySupport - use SimpleMessageListenerContainer (non-txn aware) or DefaultMessageListenerContainer (txn aware)</li>
	</ul>	
    <font color='blue' size="4">JMS Listener as POJO</font>
    <p><strong>Yes</strong> - just register  in XML inside a listener-container</p>
<pre class="prettyprint"><code class="language-xml">&lt;jms:listener destination="d" ref="myDelegate" method="m" response-destination="rd" /&gt;
</code></pre>
	<p>MEM:</p>
	<ul>
		<li>destination is where we listen for a message</li>
		<li>response-destination is needed if the method  doesn't return void</li>
	</ul>
	<h4>5.3.3 Is it possible to run JMS inside a plain Servlet container without full Java EE support (such as Tomcat or Jetty)?</h4>
	<p><strong>Yes</strong> - with usage SimpleMessageListenerContainer (for basics) or DefaultMessageListenerContainer (for transactions).</p>


	<h3>5.4 JMX</h3>
	<h4>5.4.1 Role of the MBeanExporter</h4>
	<p>Expose POJO as MBean. This class is responsible for taking your Spring beans and registering them with a JMX MBeanServer.</p>
	<h4>5.4.2 Using Spring JMX, is it possible to export a POJO as an MBean?</h4>
	<p><strong>Yes</strong> - register as a bean and use MBeanExporter</p>
<pre class="prettyprint"><code class="language-xml">&lt;bean class="org.springframework.jmx.export.MBeanExporter"&gt;
    &lt;property name="beans"&gt;
        &lt;util:map&gt;
            &lt;entry key="bean:name=mine" value-ref="beanRef" /&gt;
        &lt;/util:map&gt;
    &lt;/property&gt;
&lt;/bean&gt;
</code></pre>
	<ul>
		<li>Bean is exposed as an MBean under the ObjectName  bean:name=mine</li>
		<li>By default, the Spring MBeanExporter exports all public properties of a bean as MBean attributes and all public methods as MBean  operations.</li>
		<li>Use an MBeanInfoAssembler to control attributes and operations</li>
		<li>Use org.springframework.jmx.export.annotation.AnnotationMBeanExporter to detect @ManagedResource annotations</li>
		<li>Use &lt;context:mbean-export server=&quot;mbeanServer&quot;  default-domain=&quot;bean&quot; /&gt;</li>
	</ul>
	<h4>5.4.3 Using Spring JMX, is it possible to automatically register an existing MBean with an MBeanServer?</h4>
	<p><strong>Yes</strong> - just register them as a bean in the XML config and Spring will notice they are already MBeans (i.e those beans implementing classes that end in MBean).</p>
	<h4>5.4.4 Purpose of the @ManagedResource, @ManagedAttribute and @ManagedOperation annotations</h4>
	<ul>
		<li><strong>@ManagedResource</strong>(objectName=&quot;mine&quot;) - identifies class as MBean</li>
		<li><strong>@ManagedAttribute</strong> – expose field to JMX – place on getter and setter</li>
		<li><strong>@ManagedOperation</strong> – expose method to JMX </li>
	</ul>
	<h4><font color='brown'>5.4.5 How to declare an MBeanServer</font></h4>
      <p>Export MBeans: &lt;context:mbean-export /&gt; <br>
        Automatic registration of existing MBeans: &lt;bean  id=&quot;mine&quot; class=&quot;ExistingMBean&quot; /&gt;<br>
        Define MBeanServer: &lt;context:mbean-server /&gt; </p>
      <p>Or declare the MBeanServerFactoryBean with the  locateExistingServerIfPossible property so it can use an existing server or  create a new one.</p>
      <h4>5.4.6 Accessing remote MBean (through a proxy)</h4>
<pre class="prettyprint"><code class="language-xml">&lt;bean id="mbeanServerConnection"... /&gt;
    &lt;bean  id="..." class="org.springframework.jmx.access.MBeanProxyFactoryBean"&gt;
        &lt;property name="server" ref="mbeanServerConnection" /&gt;
        &lt;property name="objectName" value="bean:name=mine" /&gt;
        &lt;property name="proxyInterface" value="Mine" /&gt;
    &lt;/bean&gt;
&lt;/beans&gt;
</code></pre>
 
</body>
</html>